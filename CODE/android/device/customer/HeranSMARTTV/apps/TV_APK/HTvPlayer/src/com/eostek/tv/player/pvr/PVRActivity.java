package com.eostek.tv.player.pvr;import java.io.BufferedReader;import java.io.File;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FilenameFilter;import java.io.IOException;import java.util.ArrayList;import com.eostek.tv.player.PlayerActivity;import com.eostek.tv.player.R;import com.eostek.tv.player.pvr.USBDiskSelecter.usbListener;import com.eostek.tv.player.util.ChannelManagerExt;import com.eostek.tv.player.util.MTSView;import com.mstar.android.MKeyEvent;import com.mstar.android.storage.MStorageManager;import com.mstar.android.tv.TvChannelManager;import com.mstar.android.tv.TvCommonManager;import com.mstar.android.tv.TvPvrManager;import com.mstar.android.tvapi.common.TimerManager;import com.mstar.android.tvapi.common.TvManager;import com.mstar.android.tvapi.common.exception.TvCommonException;import com.mstar.android.tvapi.common.vo.CaptureThumbnailResult;import com.mstar.android.tvapi.common.vo.EnumPvrStatus;import com.mstar.android.tvapi.common.vo.ProgramInfo;import com.mstar.android.tvapi.common.vo.PvrPlaybackSpeed.EnumPvrPlaybackSpeed;import com.mstar.android.tvapi.dtv.vo.DtvAudioInfo;import com.mstar.android.tvapi.dtv.vo.EpgEventInfo;import android.animation.Animator;import android.animation.Animator.AnimatorListener;import android.animation.AnimatorListenerAdapter;import android.animation.AnimatorSet;import android.animation.ObjectAnimator;import android.app.Activity;import android.app.AlertDialog;import android.app.Dialog;import android.app.ProgressDialog;import android.content.BroadcastReceiver;import android.content.Context;import android.content.DialogInterface;import android.content.DialogInterface.OnKeyListener;import android.content.Intent;import android.content.IntentFilter;import android.content.SharedPreferences;import android.net.Uri;import android.os.Bundle;import android.os.Environment;import android.os.Handler;import android.os.Message;import android.os.StatFs;import android.text.format.Time;import android.util.Log;import android.view.KeyEvent;import android.view.LayoutInflater;import android.view.View;import android.view.View.OnClickListener;import android.view.ViewGroup;import android.view.animation.AccelerateDecelerateInterpolator;import android.view.animation.Animation;import android.view.animation.DecelerateInterpolator;import android.widget.Button;import android.widget.EditText;import android.widget.FrameLayout;import android.widget.ImageButton;import android.widget.ProgressBar;import android.widget.RelativeLayout;import android.widget.RelativeLayout.LayoutParams;import android.widget.TextView;import android.widget.Toast;public class PVRActivity extends Activity {    public static boolean isPVRActivityActive = false;    public enum PVR_MODE {        // /pvr mode none        E_PVR_MODE_NONE,        // /pvr mode record        E_PVR_MODE_RECORD,        // /pvr mode playback        E_PVR_MODE_PLAYBACK,        // /pvr mode time shift        E_PVR_MODE_TIME_SHIFT,        // /pvr mode always time shift        E_PVR_MODE_ALWAYS_TIME_SHIFT,        // /pvr mode file browser        E_PVR_MODE_FILE_BROWSER,        // /pvr mode short        E_PVR_MODE_SHORT,    }    public enum PVR_AB_LOOP_STATUS {        // /pvr ab loop not set        E_PVR_AB_LOOP_STATUS_NONE,        // /pvr ab loop set a position        E_PVR_AB_LOOP_STATUS_A,        // /pvr ab loop set b position        E_PVR_AB_LOOP_STATUS_AB,    }    // save current video's frequency.    public static int currentRecordingProgrammFrency = -1;    private static final int INVALID_TIME = 0xFFFFFFFF;    private PVR_AB_LOOP_STATUS setPvrABLoop = PVR_AB_LOOP_STATUS.E_PVR_AB_LOOP_STATUS_NONE;    private int pvrABLoopStartTime = INVALID_TIME;    private int pvrABLoopEndTime = INVALID_TIME;    private PVR_MODE curPvrMode = PVR_MODE.E_PVR_MODE_NONE;    private final int savingProgress = 0;    private final int timeChoose = 1;    private Handler handler = new Handler();    private boolean isMenuHide = false;    private boolean isBrowserCalled = false;    private boolean isOneTouchPlayMode = false;    private boolean isOneTouchPauseMode = false;    private boolean isNotifyRecordStop = false;    private boolean isWatchRcodFilInRcoding = false;    private TvPvrManager pvr = null;    private PVRImageFlag pvrImageFlag = null;    private RelativeLayout rootView = null;    private RelativeLayout recordingView = null;    private ImageButton recorder = null;    private ImageButton play = null;    private ImageButton stop = null;    private ImageButton pause = null;    private ImageButton rev = null;    private ImageButton ff = null;    private ImageButton slow = null;    private ImageButton time = null;    private ImageButton backward = null;    private ImageButton forward = null;    // private ImageButton capture = null;    private TextView serviceNameText = null;    private TextView eventNameText = null;    private TextView totalRecordTime = null;    private TextView usbLabel = null;    private TextView usbPercentage = null;    private Activity activity = null;    private String recordDiskPath = null;    private String recordDiskLable = null;    private USBDiskSelecter usbSelecter = null;    private AnimatorSet menuShowAnimation;    private AnimatorSet menuHideAnimation;    private AnimatorSet recordIconAnimation;    private AlertDialog timeChooser = null;    private PVRThumbnail thumbnail = null;    private TextProgressBar RPProgress = null;    private ProgressBar usbFreeSpace = null;    private Button resetJump2Timebtn = null;    /* For prompt alert dialog to notify user */    private static Dialog stopRecordDialog = null;    private KeyEvent tPreviousEvent;    private static final String TAG = PVRActivity.class.getSimpleName();    // ham    private TextView textViewPlay = null;    // private ImageView imgViewLoopAB = null;    private ProgressBar progress_loopab = null;    private int A_progress = 0;    private android.widget.RelativeLayout.LayoutParams lp4LoopAB;    private int looptime;    private int currentlooptime;    private TextView playSpeed;    private short audioLangPosLive = -1;    public static String sLastRecordedFileName = null;    private static final int MENUDISMISS = 0x09;    private static final int MENUDISMISSDELAYTIME = 10 * 1000;    private MyUsbReceiver usbReceiver = null;    private String mPvrRecordStr;    private ChannelManagerExt mChannelManagerExt;    /**     * main sub language     */    private FrameLayout parent = null;    private MTSView mMtsView = null;    private int mCurInputSource = TvCommonManager.INPUT_SOURCE_DTV;    private Handler myHandler = new Handler() {        @Override        public void handleMessage(Message msg) {            super.handleMessage(msg);            isMenuHide = true;            rootView.setVisibility(View.GONE);        }    };    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        mChannelManagerExt = ChannelManagerExt.getInstance();        setContentView(R.layout.eos_pvr_menu);        parent = (FrameLayout) findViewById(R.id.parent);        activity = this;        isPVRActivityActive = true;        pvr = TvPvrManager.getInstance();        pvrImageFlag = new PVRImageFlag();        rootView = (RelativeLayout) findViewById(R.id.pvrrootmenu);        recordingView = (RelativeLayout) findViewById(R.id.pvrisrecording);        recorder = (ImageButton) findViewById(R.id.player_recorder);        play = (ImageButton) findViewById(R.id.player_play);        stop = (ImageButton) findViewById(R.id.player_stop);        pause = (ImageButton) findViewById(R.id.player_pause);        rev = (ImageButton) findViewById(R.id.player_rev);        ff = (ImageButton) findViewById(R.id.player_ff);        slow = (ImageButton) findViewById(R.id.player_slow);        time = (ImageButton) findViewById(R.id.player_time);        backward = (ImageButton) findViewById(R.id.player_backward);        forward = (ImageButton) findViewById(R.id.player_forward);        serviceNameText = (TextView) findViewById(R.id.textView1);        eventNameText = (TextView) findViewById(R.id.textView2);        totalRecordTime = (TextView) findViewById(R.id.record_time);        totalRecordTime.setText("00:00:00");        playSpeed = (TextView) findViewById(R.id.play_speed);        playSpeed.setVisibility(View.GONE);        usbLabel = (TextView) findViewById(R.id.usbLabelName);        usbPercentage = (TextView) findViewById(R.id.usbFreeSpacePercent);        RPProgress = (TextProgressBar) findViewById(R.id.play_record_progress);        usbFreeSpace = (ProgressBar) findViewById(R.id.usbFreeSpace);        usbFreeSpace.setMax(100);        pvrImageFlag.setPauseFlag(true);        // ham        textViewPlay = (TextView) findViewById(R.id.text_view_player_play);        progress_loopab = (ProgressBar) findViewById(R.id.progressbar_loopab);        lp4LoopAB = new android.widget.RelativeLayout.LayoutParams(0, dip2px(5));        lp4LoopAB.topMargin = 5;        mPvrRecordStr = getResources().getString(R.string.str_pvr_is_recording);        if (getIntent().getExtras() != null) {            isBrowserCalled = getIntent().getExtras().getBoolean("FullPageBrowserCall", false);            isOneTouchPlayMode = (getIntent().getExtras().getInt("PVR_ONE_TOUCH_MODE") == 2);            isOneTouchPauseMode = (getIntent().getExtras().getInt("PVR_ONE_TOUCH_MODE") == 3);            if (isBrowserCalled || isOneTouchPlayMode) {                findViewById(R.id.player_recorder_icon).setVisibility(View.GONE);                findViewById(R.id.usbInfoLayout).setVisibility(View.GONE);                pvrImageFlag.setPauseFlag(false);                curPvrMode = PVR_MODE.E_PVR_MODE_PLAYBACK;            }            if (isOneTouchPauseMode) {                // Do PVR TimeShift!!!!!                curPvrMode = PVR_MODE.E_PVR_MODE_TIME_SHIFT;                mPvrRecordStr = getResources().getString(R.string.str_pvr_is_time_shift);            } else {                // set pvr bar status                setBarStatusOfStartRecord();            }        } else {            // set pvr bar status            setBarStatusOfStartRecord();        }        Log.v(TAG, "mPvrRecordStr = " + mPvrRecordStr);        usbSelecter = new USBDiskSelecter(activity) {            @Override            public void onItemChosen(int position, String diskLabel, String diskPath) {                recordDiskPath = diskPath;                recordDiskLable = diskLabel;                usbLabel.setText(diskLabel);                Log.d(TAG, "current Selected Disk = " + recordDiskPath);                Log.e(TAG, "current selected DiskLabel=" + recordDiskLable);                try {                    if (isOneTouchPauseMode) {                        doPVRTimeShift(true);                        new PlayBackProgress().start();                    } else {                        String fat = "FAT";                        String ntfs = "NTFS";                        if (recordDiskLable.regionMatches(6, fat, 0, 3)) {                            doPVRRecord(true);                            new PlayBackProgress().start();                        } else if (recordDiskLable.regionMatches(6, ntfs, 0, 4) || !recordDiskLable.contains(fat)) {                            this.noDismiss = true;                            Toast.makeText(activity, R.string.str_pvr_unsurpt_flsystem, Toast.LENGTH_LONG).show();                            finish();                            return;                        }                    }                } catch (TvCommonException e) {                    e.printStackTrace();                }            }        };        usbSelecter.setUSBListener(new usbListener() {            @Override            public void onUSBUnmounted(String diskPath) {            }            @Override            public void onUSBMounted(String diskPath) {            }            @Override            public void onUSBEject(String diskPath) {                if (recordDiskPath == null || !recordDiskPath.equals(diskPath)) {                    return;                }                if (pvr.isPlaybacking()) {                    resumeLang();                    resumeSubtitle();                    pvr.stopPlayback();                    pvr.stopPlaybackLoop();                }                if (pvr.isTimeShiftRecording()) {                    pvr.stopTimeShift();                }                pvr.stopRecord();                finish();                // move the disk when current status is record in boot.TV will                // go to standby.                if (isBootedByRecord()) {                    standbySystem();                }            }        });        thumbnail = new PVRThumbnail(this, pvr) {            @Override            void onItemClicked(int position) {                JumpToThumbnail(position);            }        };        ((RelativeLayout) findViewById(R.id.thumbnailRoot)).addView(thumbnail);        LayoutParams lp = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);        lp.addRule(RelativeLayout.ALIGN_PARENT_TOP);        thumbnail.setLayoutParams(lp);        thumbnail.Show(false);        recorder.setOnClickListener(new OnClickListener() {            @Override            public void onClick(View v) {                createAnimation();                try {                    onKeyRecord();                } catch (TvCommonException e) {                    e.printStackTrace();                }            }        });        play.setOnClickListener(new OnClickListener() {            @Override            public void onClick(View v) {                try {                    onKeyPlay();                } catch (TvCommonException e) {                    e.printStackTrace();                }            }        });        stop.setOnClickListener(new OnClickListener() {            @Override            public void onClick(View v) {                pvrImageFlag.setStopFlag(true);                try {                    onKeyStop();                } catch (TvCommonException e) {                    e.printStackTrace();                }            }        });        pause.setOnClickListener(new OnClickListener() {            @Override            public void onClick(View v) {                try {                    onKeyPause();                } catch (TvCommonException e) {                    e.printStackTrace();                }            }        });        rev.setOnClickListener(new OnClickListener() {            @Override            public void onClick(View v) {                try {                    onKeyRev();                } catch (TvCommonException e) {                    e.printStackTrace();                }                requestFocus();                rev.setImageResource(R.drawable.player_rev_focus);                pvrImageFlag.setRevFlag(true);            }        });        ff.setOnClickListener(new OnClickListener() {            @Override            public void onClick(View v) {                try {                    onKeyFF();                } catch (TvCommonException e) {                    e.printStackTrace();                }                requestFocus();                ff.setImageResource(R.drawable.player_ff_focus);                pvrImageFlag.setFfFlag(true);            }        });        slow.setOnClickListener(new OnClickListener() {            @Override            public void onClick(View v) {                try {                    onKeySlowMotion();                } catch (TvCommonException e) {                    e.printStackTrace();                }                requestFocus();                slow.setImageResource(R.drawable.player_slow_focus);                pvrImageFlag.setSlowFlag(true);            }        });        time.setOnClickListener(new OnClickListener() {            @Override            public void onClick(View v) {                try {                    onKeyGoToTime();                } catch (TvCommonException e) {                    e.printStackTrace();                }                time.setImageResource(R.drawable.player_time_focus);                pvrImageFlag.setTimeFlag(true);            }        });        backward.setOnClickListener(new OnClickListener() {            @Override            public void onClick(View v) {                try {                    onKeyBackward();                } catch (TvCommonException e) {                    e.printStackTrace();                }                requestFocus();                backward.setImageResource(R.drawable.player_backward_focus);                pvrImageFlag.setBackwardFlag(true);            }        });        forward.setOnClickListener(new OnClickListener() {            @Override            public void onClick(View v) {                try {                    onKeyForward();                } catch (TvCommonException e) {                    e.printStackTrace();                }                requestFocus();                forward.setImageResource(R.drawable.player_forward_focus);                pvrImageFlag.setFowardFlag(true);            }        });        /*         * capture.setOnClickListener(new OnClickListener() {         * @Override public void onClick(View v) { try { onKeyCapture(); } catch         * (TvCommonException e) { e.printStackTrace(); }         * capture.setImageResource(R.drawable.player_capture_focus);         * pvrImageFlag.setCaptureFlag(true); } });         */        // show info and start record        if (isBrowserCalled) {            serviceNameText.setText(getIntent().getStringExtra("channel"));            eventNameText.setText(getIntent().getStringExtra("channelEvent"));        } else {            ChannelManagerExt cd = ChannelManagerExt.getInstance();            ProgramInfo curProgInfo = null;            EpgEventInfo epgEventInfo = new EpgEventInfo();            // get service info            curProgInfo = cd.getCurProgramInfo();            String serviceNumberAndNameStr = "CH" + curProgInfo.number + " " + curProgInfo.serviceName;            serviceNameText.setText(serviceNumberAndNameStr);            // get event info            epgEventInfo = cd.getCurEpgEventInfo(curProgInfo);            if (epgEventInfo != null) {                eventNameText.setText(epgEventInfo.name);            }            pvrABLoopStartTime = INVALID_TIME;            pvrABLoopEndTime = INVALID_TIME;            setPvrABLoop = PVR_AB_LOOP_STATUS.E_PVR_AB_LOOP_STATUS_NONE;        }        if (isBrowserCalled) {            play.performClick();            int total;            total = pvr.getRecordedFileDurationTime(pvr.getCurPlaybackingFileName());            RPProgress.setMax(total);            totalRecordTime.setText(getTimeString(total));            /*             * to avoid request focus on stop or other image button , give the             * request to invisible image button when the first focus is on the             * stop button, when press the enter in pvr brower page, it will             * perform button onclick             */            recorder.setEnabled(false);            recorder.requestFocus();            new BrowserCalledPlayBackProgress().start();        } else {            if (isOneTouchPlayMode) {                play.performClick();                String pvrFileName = getIntent().getExtras().getString("PVRRECORDEDFILE");                if (pvrFileName == null) {                    Log.e(TAG, "pvrFileName is NULL！");                    finish();                    return;                }                String pvrFileLcn = null;                String pvrFileServiceName = null;                String pvrFileEventName = null;                pvrFileLcn = "CH " + pvr.getFileLcn(0);                pvrFileServiceName = pvr.getFileServiceName(pvrFileName);                pvrFileEventName = pvr.getFileEventName(pvrFileName);                String pvrFileServiceNumberAndNameStr = pvrFileLcn + " " + pvrFileServiceName;                serviceNameText.setText(pvrFileServiceNumberAndNameStr);                eventNameText.setText(pvrFileEventName);                Log.d(TAG, "pvrFileNumber = " + pvr.getPvrFileNumber());                Log.d(TAG, "current playback fileName = " + pvrFileName);                Log.d(TAG, "pvrFileLcn = " + pvrFileLcn);                Log.d(TAG, "pvrFileServiceName = " + pvrFileServiceName);                Log.d(TAG, "pvrFileEventName = " + pvrFileEventName);                if (pvr.isPlaybacking()) {                    pvr.stopPlayback();                    pvr.stopPlaybackLoop();                }                EnumPvrStatus playbackStatus = pvr.startPlayback(pvrFileName);                Log.d(TAG, "playbackStatus = " + playbackStatus);                if (!playbackStatus.equals(EnumPvrStatus.E_SUCCESS)) {                    Toast.makeText(this, R.string.pvrplayererror, Toast.LENGTH_LONG).show();                }                int totalTime = pvr.getRecordedFileDurationTime(pvrFileName);                Log.d(TAG, "totalTime = " + totalTime);                RPProgress.setMax(totalTime);                totalRecordTime.setText(getTimeString(totalTime));                stop.requestFocus();                new PlayBackProgress().start();            } else {                recorder.performClick();            }        }        myHandler.sendEmptyMessageDelayed(MENUDISMISS, MENUDISMISSDELAYTIME);    }    @Override    protected void onStart() {        super.onStart();        registerUSBDetector();    }    private void registerUSBDetector() {        usbReceiver = new MyUsbReceiver();        IntentFilter iFilter;        iFilter = new IntentFilter(Intent.ACTION_MEDIA_MOUNTED);        iFilter.addDataScheme("file");        registerReceiver(usbReceiver, iFilter);        iFilter = new IntentFilter(Intent.ACTION_MEDIA_EJECT);        iFilter.addDataScheme("file");        registerReceiver(usbReceiver, iFilter);    }    @Override    public boolean dispatchKeyEvent(KeyEvent event) {        // Shielding global key        switch (event.getKeyCode()) {            case KeyEvent.KEYCODE_TV_INPUT:            case MKeyEvent.KEYCODE_MSTAR_REVEAL:            case MKeyEvent.KEYCODE_MSTAR_UPDATE:            case MKeyEvent.KEYCODE_CC:            case MKeyEvent.KEYCODE_SUBTITLE:            case KeyEvent.KEYCODE_PROG_GREEN:            case KeyEvent.KEYCODE_APP_SWITCH:            case MKeyEvent.KEYCODE_TV_SETTING:                if (rootView.getVisibility() != View.VISIBLE) {                    rootView.setVisibility(View.VISIBLE);                }                return true;            default:                break;        }        myHandler.removeMessages(MENUDISMISS);        myHandler.sendEmptyMessageDelayed(MENUDISMISS, MENUDISMISSDELAYTIME);        return super.dispatchKeyEvent(event);    }    @Override    public void onBackPressed() {        boolean bIsTimeShiftRecording = false;        bIsTimeShiftRecording = pvr.isTimeShiftRecording();        if (!bIsTimeShiftRecording) {            // Recording            if (!isMenuHide && pvrImageFlag.isRecorderFlag() || bIsTimeShiftRecording) {                AlertDialog.Builder dialog = new AlertDialog.Builder(this);                dialog.setTitle(R.string.tips).setMessage(R.string.str_pvr_exit_confirm)                        .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {                            @Override                            public void onClick(DialogInterface dialog, int arg1) {                                dialog.dismiss();                                if (pvr.isPlaybacking()) {                                    resumeLang();                                    resumeSubtitle();                                    pvr.stopPlayback();                                    pvr.stopPlaybackLoop();                                }                                if (pvr.isTimeShiftRecording()) {                                    pvr.stopTimeShift();                                }                                PVRActivity.currentRecordingProgrammFrency = -1;                                saveAndExit();                            }                        }).setNegativeButton(android.R.string.cancel, new DialogInterface.OnClickListener() {                            @Override                            public void onClick(DialogInterface dialog, int arg1) {                                dialog.dismiss();                            }                        }).show();            } else if (isMenuHide && (pvrImageFlag.isRecorderFlag() || bIsTimeShiftRecording)) {                menuShow();            } else {                if (isOneTouchPlayMode && pvr.isPlaybacking()) {                    pvr.stopPlayback();                    pvr.stopPlaybackLoop();                }                if (isBrowserCalled) {                    Intent intent = new Intent(this, PVRFullPageBrowserActivity.class);                    startActivity(intent);                }                finish();            }            return;        }        // TimeShift        if (!isMenuHide && pvrImageFlag.isTimeFlag() || bIsTimeShiftRecording) {            AlertDialog.Builder dialog = new AlertDialog.Builder(this);            dialog.setTitle(R.string.tips).setMessage(R.string.str_pvr_time_shift_exit_confirm)                    .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {                        @Override                        public void onClick(DialogInterface dialog, int arg1) {                            dialog.dismiss();                            if (pvr.isPlaybacking()) {                                resumeLang();                                resumeSubtitle();                                pvr.stopPlayback();                                pvr.stopPlaybackLoop();                            }                            if (pvr.isTimeShiftRecording()) {                                pvr.stopTimeShift();                            }                            PVRActivity.currentRecordingProgrammFrency = -1;                            saveAndExit();                        }                    }).setNegativeButton(android.R.string.cancel, new DialogInterface.OnClickListener() {                        @Override                        public void onClick(DialogInterface dialog, int arg1) {                            dialog.dismiss();                        }                    }).show();        } else if (isMenuHide && (pvrImageFlag.isTimeFlag() || bIsTimeShiftRecording)) {            menuShow();        } else {            if (isOneTouchPlayMode && pvr.isPlaybacking()) {                pvr.stopPlayback();                pvr.stopPlaybackLoop();            }            if (isBrowserCalled) {                Intent intent = new Intent(this, PVRFullPageBrowserActivity.class);                startActivity(intent);            }            // finish();        }    }    @Override    public void onResume() {        super.onResume();        // Use for press "index" key in PVR recording state then back to PVR        // activity.        isWatchRcodFilInRcoding = false;        mChannelManagerExt.getAllChannels(this, mCurInputSource);    }    @Override    public void onNewIntent(Intent intent) {        super.onNewIntent(intent);        // must store the new intent unless getIntent() will return the old one        setIntent(intent);        if (getIntent().getExtras() != null) {            isNotifyRecordStop = (getIntent().getExtras().getInt("PVR_ONE_TOUCH_MODE") == 4);            boolean isNotifyPlaybackStop = (getIntent().getExtras().getInt("PVR_PLAYBACK_STOP") == 11);            Log.e(TAG, "isNotifyRecordStop = " + isNotifyRecordStop);            if (isNotifyPlaybackStop) {                if (pvr.isPlaybacking()) {                    resumeLang();                    resumeSubtitle();                    pvr.stopPlayback();                    pvr.stopPlaybackLoop();                    finish();                }            }            if (isNotifyRecordStop) {                saveAndExit();                boolean isBootedByRecord = TvManager.getInstance().getPvrManager().getIsBootByRecord();                if (isBootedByRecord) {                    // goto standby                    TvManager.getInstance().getPvrManager().setIsBootByRecord(false);                    TvCommonManager.getInstance().standbySystem("standby");                }            }        }    }    /**     * For prompt alert dialog to notify user     */    private class OnStopRecordCancelClickListener implements DialogInterface.OnClickListener {        @Override        public void onClick(DialogInterface dialog, int which) {            Log.i(TAG, "OnStopRecordCancelClickListener onClick");            dialog.dismiss();            stopRecordDialog = null;        }    }    private class OnStopRecordConfirmClickListener implements DialogInterface.OnClickListener {        @Override        public void onClick(DialogInterface dialog, int which) {            ChannelManagerExt channelManager = ChannelManagerExt.getInstance();            dialog.dismiss();            stopRecordDialog = null;            if (pvr.isPlaybacking()) {                resumeLang();                resumeSubtitle();                pvr.stopPlayback();                pvr.stopPlaybackLoop();            }            saveAndExit();            switch (tPreviousEvent.getKeyCode()) {                case KeyEvent.KEYCODE_CHANNEL_UP:                    channelManager.channelUp();                    break;                case KeyEvent.KEYCODE_CHANNEL_DOWN:                    channelManager.channelDown();                    break;                case MKeyEvent.KEYCODE_CHANNEL_RETURN:                    channelManager.channelReturn();                    break;            }            finish();        }    }    private boolean showStopRecordDialog() {        boolean bRet = true;        do {            if (stopRecordDialog != null && stopRecordDialog.isShowing()) {                Log.e(TAG, "StopRecordDialog allready exist");                bRet = false;                break;            }            AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(this);            dialogBuilder = dialogBuilder.setTitle(R.string.str_stop_record_dialog_title);            dialogBuilder = dialogBuilder.setMessage(R.string.str_stop_record_dialog_message);            dialogBuilder = dialogBuilder                    .setPositiveButton(android.R.string.ok, new OnStopRecordConfirmClickListener());            dialogBuilder = dialogBuilder.setNegativeButton(android.R.string.cancel,                    new OnStopRecordCancelClickListener());            if (dialogBuilder == null) {                Log.e(TAG, "showStopRecordDialog -- AlertDialog.Builder init fail");                bRet = false;                break;            }            stopRecordDialog = dialogBuilder.create();            if (stopRecordDialog == null) {                Log.e(TAG, "showStopRecordDialog -- AlertDialog.Builder create dialog fail");                bRet = false;                break;            }            stopRecordDialog.show();        } while (false);        return bRet;    }    private boolean CheckNeedToStopRecord(KeyEvent tEvent) {        boolean bRet = false;        do {            boolean bRecordNow = false;            bRecordNow = pvr.isRecording();            int keyCode = tEvent.getKeyCode();            if ((keyCode != KeyEvent.KEYCODE_CHANNEL_UP) && (keyCode != KeyEvent.KEYCODE_CHANNEL_DOWN)                    && (keyCode != MKeyEvent.KEYCODE_CHANNEL_RETURN)) {                break;            }            if (!bRecordNow) {                break;            }            if (isMenuHide == true) {                bRet = true;                menuShow();                break;            }            tPreviousEvent = tEvent;            bRet = showStopRecordDialog();        } while (false);        return bRet;    }    @Override    public boolean onKeyDown(int keyCode, KeyEvent event) {        switch (keyCode) {            case KeyEvent.KEYCODE_MENU:            case KeyEvent.KEYCODE_ENTER:            case KeyEvent.KEYCODE_DPAD_CENTER:            case KeyEvent.KEYCODE_INFO:                if (rootView.getVisibility() != View.VISIBLE) {                    rootView.setVisibility(View.VISIBLE);                }                return true;            case KeyEvent.KEYCODE_PROG_BLUE: {                try {                    onKeyCapture();                } catch (TvCommonException e) {                    e.printStackTrace();                }                return true;            }            case KeyEvent.KEYCODE_PROG_GREEN: {                boolean isTSRecording = false;                isTSRecording = pvr.isTimeShiftRecording();                if (!isTSRecording) {                    thumbnail.Show(!thumbnail.isShown());                }                return true;            }            case KeyEvent.KEYCODE_PROG_YELLOW: {                boolean isTSRecording = false;                isTSRecording = pvr.isTimeShiftRecording();                if (!isTSRecording) {                    RemoveThumbnail();                }                return true;            }            case MKeyEvent.KEYCODE_MSTAR_INDEX: {                isWatchRcodFilInRcoding = true;                Intent intent = new Intent(this, PVRFullPageBrowserActivity.class);                startActivity(intent);                return true;            }            case MKeyEvent.KEYCODE_MTS: {                if (mChannelManagerExt.getChannels().size() > 0) {                    if (mMtsView == null) {                        mMtsView = new MTSView(this, mCurInputSource);                        parent.addView(mMtsView);                        return true;                    }                    if (mMtsView.isShow()) {                        mMtsView.changeMtsInfo(mCurInputSource);                    } else if (!mMtsView.isShow()) {                        mMtsView.getMtsInfo(mCurInputSource);                    }                }                break;            }            case MKeyEvent.KEYCODE_SUBTITLE: {                // TODO subtitle                break;            }            case KeyEvent.KEYCODE_MEDIA_PAUSE:                pause.performClick();                return true;            case KeyEvent.KEYCODE_MEDIA_PLAY:                play.performClick();                return true;            case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:                ff.performClick();                return true;            case KeyEvent.KEYCODE_MEDIA_REWIND:                rev.performClick();                return true;            case KeyEvent.KEYCODE_MEDIA_STOP:                stop.performClick();                return true;        }        /* For prompt alert dialog to notify user */        if (CheckNeedToStopRecord(event) == true) {            return true;        }        if (keyCode != KeyEvent.KEYCODE_BACK) {            menuShow();        }        return super.onKeyDown(keyCode, event);    }    @Override    protected Dialog onCreateDialog(int id) {        switch (id) {            case savingProgress: {                ProgressDialog mpDialog = new ProgressDialog(this);                mpDialog.setMessage(getResources().getString(R.string.str_pvr_program_saving));                mpDialog.setIndeterminate(false);                mpDialog.setCancelable(false);                return mpDialog;            }            case timeChoose: {                LayoutInflater inflater = getLayoutInflater();                View layout = inflater.inflate(R.layout.eos_pvr_menu_dialog, (ViewGroup) findViewById(R.id.pvr_dialog));                resetJump2Timebtn = (Button) layout.findViewById(R.id.ResetJ2TBtn);                resetJump2Timebtn.setOnClickListener(J2TButtonListener);                timeChooser = new AlertDialog.Builder(activity).setTitle(R.string.str_player_time).setView(layout)                        .setCancelable(false)                        .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {                            @Override                            public void onClick(DialogInterface dialog, int arg1) {                                dialog.dismiss();                                myHandler.sendEmptyMessageDelayed(MENUDISMISS, MENUDISMISSDELAYTIME);                                time.setImageResource(R.drawable.playertime);                                if (timeChooser != null) {                                    int timeInSecond = ((TimeChooser) timeChooser                                            .findViewById(R.id.pvr_menu_dialog_hours)).getValue()                                            * 3600                                            + ((TimeChooser) timeChooser.findViewById(R.id.pvr_menu_dialog_minutes))                                                    .getValue()                                            * 60                                            + ((TimeChooser) timeChooser.findViewById(R.id.pvr_menu_dialog_seconds))                                                    .getValue();                                    pvr.jumpPlaybackTime(timeInSecond);                                }                            }                        }).setNegativeButton(android.R.string.cancel, new DialogInterface.OnClickListener() {                            @Override                            public void onClick(DialogInterface dialog, int arg1) {                                dialog.dismiss();                                myHandler.sendEmptyMessageDelayed(MENUDISMISS, MENUDISMISSDELAYTIME);                                time.setImageResource(R.drawable.playertime);                                timeChooser = null;                            }                        }).setOnKeyListener(new OnKeyListener() {                            @Override                            public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {                                if (keyCode == KeyEvent.KEYCODE_BACK) {                                    dialog.dismiss();                                    myHandler.sendEmptyMessageDelayed(MENUDISMISS, MENUDISMISSDELAYTIME);                                    time.setImageResource(R.drawable.playertime);                                    timeChooser = null;                                }                                return false;                            }                        }).show();                setBarStatusOfPlayToOthers();                return timeChooser;            }        }        return null;    }    private OnClickListener J2TButtonListener = new OnClickListener() {        @Override        public void onClick(View v) {            EditText hours, minutes, seconds;            if (timeChooser == null) {                return;            }            hours = (TimeChooser) timeChooser.findViewById(R.id.pvr_menu_dialog_hours);            minutes = (TimeChooser) timeChooser.findViewById(R.id.pvr_menu_dialog_minutes);            seconds = (TimeChooser) timeChooser.findViewById(R.id.pvr_menu_dialog_seconds);            hours.setText("");            minutes.setText("");            seconds.setText("");        }    };    @Override    protected void onDestroy() {        super.onDestroy();        usbSelecter.dismiss();        if (isBrowserCalled && pvr.isPlaybacking()) {            resumeLang();            resumeSubtitle();            pvr.stopPlayback();            pvr.stopPlaybackLoop();        }    }    public void setBarStatusOfStartRecord() {        recorder.setEnabled(true);        play.setEnabled(true);        stop.setEnabled(true);        pause.setEnabled(true);        rev.setEnabled(false);        ff.setEnabled(false);        slow.setEnabled(false);        time.setEnabled(false);        backward.setEnabled(false);        forward.setEnabled(false);        recorder.setFocusable(true);        play.setFocusable(true);        stop.setFocusable(true);        pause.setFocusable(true);        rev.setFocusable(false);        ff.setFocusable(false);        slow.setFocusable(false);        time.setFocusable(false);        backward.setFocusable(false);        forward.setFocusable(false);        clearFocus();    }    public void setBarStatusOfRecordToPlay() {        recorder.setEnabled(false);        play.setEnabled(false);        stop.setEnabled(true);        pause.setEnabled(true);        rev.setEnabled(true);        ff.setEnabled(true);        slow.setEnabled(true);        time.setEnabled(true);        backward.setEnabled(true);        forward.setEnabled(true);        recorder.setFocusable(false);        play.setFocusable(false);        stop.setFocusable(true);        pause.setFocusable(true);        rev.setFocusable(true);        ff.setFocusable(true);        slow.setFocusable(true);        time.setFocusable(true);        backward.setFocusable(true);        forward.setFocusable(true);        requestFocus();    }    public void setBarStatusOfRecordToPause() {        recorder.setEnabled(true);        play.setEnabled(true);        stop.setEnabled(true);        pause.setEnabled(true);        rev.setEnabled(false);        ff.setEnabled(false);        slow.setEnabled(false);        time.setEnabled(false);        backward.setEnabled(false);        forward.setEnabled(false);        recorder.setFocusable(true);        play.setFocusable(true);        stop.setFocusable(true);        pause.setFocusable(true);        rev.setFocusable(false);        ff.setFocusable(false);        slow.setFocusable(false);        time.setFocusable(false);        backward.setFocusable(false);        forward.setFocusable(false);        clearFocus();    }    private void requestFocus() {        rev.setImageResource(R.drawable.player_rev);        ff.setImageResource(R.drawable.player_ff);        slow.setImageResource(R.drawable.player_slow);        time.setImageResource(R.drawable.playertime);        backward.setImageResource(R.drawable.player_backward);        forward.setImageResource(R.drawable.player_forward);    }    private void clearFocus() {        rev.setImageResource(R.drawable.player_rev_d);        ff.setImageResource(R.drawable.player_ff_d);        slow.setImageResource(R.drawable.player_slow_d);        time.setImageResource(R.drawable.playertime_d);        backward.setImageResource(R.drawable.player_backward_d);        forward.setImageResource(R.drawable.player_forward_d);    }    public void setBarStatusOfPlayToPause() {        recorder.setEnabled(true);        play.setEnabled(true);        stop.setEnabled(false);        pause.setEnabled(true);        rev.setEnabled(true);        ff.setEnabled(true);        slow.setEnabled(true);        time.setEnabled(true);        backward.setEnabled(true);        forward.setEnabled(true);        recorder.setFocusable(true);        play.setFocusable(true);        stop.setFocusable(false);        pause.setFocusable(true);        rev.setFocusable(true);        ff.setFocusable(true);        slow.setFocusable(true);        time.setFocusable(true);        backward.setFocusable(true);        forward.setFocusable(true);        requestFocus();    }    public void setBarStatusOfPlayToOthers() {        recorder.setEnabled(true);        play.setEnabled(true);        stop.setEnabled(true);        pause.setEnabled(true);        rev.setEnabled(true);        ff.setEnabled(true);        slow.setEnabled(true);        time.setEnabled(true);        backward.setEnabled(true);        forward.setEnabled(true);        recorder.setFocusable(true);        play.setFocusable(true);        stop.setFocusable(true);        pause.setFocusable(true);        rev.setFocusable(true);        ff.setFocusable(true);        slow.setFocusable(true);        time.setFocusable(true);        backward.setFocusable(true);        forward.setFocusable(true);        requestFocus();    }    private boolean getChooseDiskSettings() {        SharedPreferences sp = getSharedPreferences("save_setting_select", MODE_PRIVATE);        return sp.getBoolean("IS_ALREADY_CHOOSE_DISK", false);    }    private String getChooseDiskPath() {        SharedPreferences sp = getSharedPreferences("save_setting_select", MODE_PRIVATE);        return sp.getString("DISK_PATH", "unknown");    }    private boolean isFileExisted(String path) {        if (path == null || "".equals(path)) {            return false;        } else {            File file = new File(path);            if (file.exists()) {                return true;            } else {                return false;            }        }    }    private static class DirectoryFilter implements FilenameFilter {        @Override        public boolean accept(File dir, String filename) {            if (new File(dir, filename).isDirectory())                return true;            else {                return false;            }        }    }    private boolean isFATDisk(String diskPath) {        Log.e(TAG, "isFATDisk diskPath:" + diskPath);        String label = getUsbLabelByPath(new String(diskPath));        Log.e(TAG, "isFATDisk label:" + label);        if (label != null && label.contains("FAT")) {            return true;        }        return false;    }    private String getFirstUseableDiskAtParentDir(String parent) {        File file = new File(parent);        if (file.isDirectory()) {            FilenameFilter filter = new DirectoryFilter();            File[] list = file.listFiles(filter);            for (File tmp : list) {                // find which in turn under the directory path to the file                // exists.                // tmp is /MNT/usb/sda1.                // only to check this directory is wrong, we need to check                // /MNT/usb/sda1/_MSTPVR/.To prevent this directory which is                // false.                // Or check the cache.f the usb is real, but there were no MSTPV                // folder, also can be.We can according to the radio.                // receiver to accept data to determine the current information.                if ((isFileExisted(tmp.getAbsolutePath() + "/_MSTPVR/") || UsbReceiver.isDiskExisted(new String(tmp                        .getAbsolutePath()))) && (isFATDisk(tmp.getAbsolutePath()))) {                    return tmp.getAbsolutePath();                }            }            // If the loop testing finished, didn't find the right path,            // indicates no insert any equipment.            return null;        } else {            return null;        }    }    private static final String NO_DISK = "NO_DISK";    private static final String CHOOSE_DISK = "CHOOSE_DISK";    private String getBestDiskPath() {        if (getChooseDiskSettings()) {            // Has chosen the disk read from the file storage disk path to pay            // attention to the label of here actually is not important, because            // it is possible and really drive on.            // eg:/MNT/usb/sda1/ pay attention to the function, if the file did            // not save in the return of the unknown.            String path = getChooseDiskPath();            // Concludes that the path to the corresponding path that exists if            // the folder is returned directly, don't need to judge the cache            // saved state or state.            if (isFileExisted(path + "/_MSTPVR") || UsbReceiver.isDiskExisted(new String(path))) {                // The path to the corresponding file exists.                return path;            } else {                // The path to the corresponding path does not exist can choose                // any one from another directory.                String parent = "/mnt/usb/";                String firstDisk = getFirstUseableDiskAtParentDir(parent);                // Didn't find a suitable directory.                if (firstDisk == null) {                    return NO_DISK;                }                // To find the right directory.                else {                    return firstDisk;                }            }        } else {            // Is not set, then select the disk and the need to control if you            // don't need to control device of 0 here may also be no disk so            // judgment is required.            return CHOOSE_DISK;        }    }    /**     * @param path like /mnt/usb/sda1     * @return According to the path to return to the path of the corresponding     *         label if we save the label this doesn't work, and should be based     *         on the path to obtain the corresponding label.     */    private String getUsbLabelByPath(String diskPath) {        MStorageManager storageManager = MStorageManager.getInstance(this);        String[] volumes = storageManager.getVolumePaths();        int usbDriverCount = 0;        ArrayList<String> usbDriverLabel = new ArrayList<String>();        ArrayList<String> usbDriverPath = new ArrayList<String>();        usbDriverLabel.clear();        usbDriverPath.clear();        if (volumes == null) {            return null;        }        File file = new File("proc/mounts");        if (!file.exists() || file.isDirectory()) {            file = null;        }        for (int i = 0; i < volumes.length; ++i) {            String state = storageManager.getVolumeState(volumes[i]);            if (state == null || !state.equals(Environment.MEDIA_MOUNTED)) {                continue;            }            String path = volumes[i];            String[] pathPartition = path.split("/");            // the last part            String label = pathPartition[pathPartition.length - 1];            String volumeLabel = storageManager.getVolumeLabel(path);            if (volumeLabel != null) {                // get rid of the long space in the Label word                String[] tempVolumeLabel = volumeLabel.split(" ");                volumeLabel = "";                for (int j = 0; j < tempVolumeLabel.length; j++) {                    if (j != tempVolumeLabel.length - 1) {                        volumeLabel += tempVolumeLabel[j] + " ";                        continue;                    }                    volumeLabel += tempVolumeLabel[j];                }            }            label += ": " + getFileSystem(file, path) + "\n" + volumeLabel;            usbDriverLabel.add(usbDriverCount, label);            usbDriverPath.add(usbDriverCount, path);            usbDriverCount++;        }        // remove diskPath start and end's/        if (diskPath.startsWith("/")) {            diskPath = diskPath.substring(1);        }        if (diskPath.endsWith("/")) {            diskPath = diskPath.substring(0, diskPath.length() - 1);        }        for (int i = 0; i < usbDriverPath.size(); i++) {            if (usbDriverPath.get(i).contains(diskPath)) {                return usbDriverLabel.get(i);            }        }        // If iterate through all the usb did not find the path of the        // corresponding label will return null.        return null;    }    private String getFileSystem(File file, String path) {        if (file == null) {            return "";        }        BufferedReader br = null;        try {            br = new BufferedReader(new FileReader(file));            String line = br.readLine();            while (line != null) {                String[] info = line.split(" ");                if (info[1].equals(path)) {                    if (info[2].equals("ntfs3g"))                        return "NTFS";                    if (info[2].equals("vfat"))                        return "FAT";                    else                        return info[2];                }                line = br.readLine();            }        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } finally {            if (br != null) {                try {                    br.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }        return "";    }    private boolean isBootedByRecord() {        boolean isBootedByRecord = TvManager.getInstance().getPvrManager().getIsBootByRecord();        return isBootedByRecord;    }    private void standbySystem() {        TvManager.getInstance().getPvrManager().setIsBootByRecord(false);        TvCommonManager.getInstance().standbySystem("standby");    }    private String getAvaliableDiskForStandBy() {        String parent = "/mnt/usb/";        String firstDisk = getFirstUseableDiskAtParentDir(parent);        return firstDisk;    }    private void cancelValidEpgTimerEvent() {        Time currTime = new Time();        currTime.setToNow();        currTime.set(currTime.toMillis(true));        TimerManager timer = TvManager.getInstance().getTimerManager();        try {            if (timer != null) {                timer.cancelEpgTimerEvent((int) ((currTime.toMillis(true) / 1000) + 10 + 3), false);            }        } catch (TvCommonException e) {            e.printStackTrace();        }    }    public void onKeyRecord() throws TvCommonException {        Log.e(TAG, "pvrImageFlag.isRecorderFlag()=" + pvrImageFlag.isRecorderFlag());        Log.e(TAG, "pvr.isRecordPaused()=" + pvr.isRecordPaused());        Log.e(TAG, "pvr.getMountPath=" + pvr.getPvrMountPath());        if (!pvrImageFlag.isRecorderFlag()) {            Log.e(TAG, "!pvrImageFlag.isRecorderFlag()");            Log.e(TAG, "pvr.isRecording =" + pvr.isRecording());            boolean isRecording = pvr.isRecording();            if (isRecording) {                // If you are recording, don't need to choose the disk.                recordDiskPath = pvr.getPvrMountPath();                recordDiskLable = getUsbLabelByPath(new String(recordDiskPath));                usbLabel.setText(recordDiskLable);                if (isOneTouchPauseMode) {                    doPVRTimeShift(true);                    new PlayBackProgress().start();                } else {                    doPVRRecord(true);                    new PlayBackProgress().start();                }            } else {                int usbDriverCount = usbSelecter.getDriverCount();                if (usbDriverCount <= 0) {                    Toast.makeText(activity, R.string.str_pvr_insert_usb, Toast.LENGTH_LONG).show();                    if (isBootedByRecord()) {                        // to cancel the epg                        cancelValidEpgTimerEvent();                        standbySystem();                    }                    finish();                    return;                }                String diskPath = getBestDiskPath();                Log.e(TAG, "getBestDiskPath:" + diskPath);                if (NO_DISK.equals(diskPath)) {                    Toast.makeText(activity, R.string.str_pvr_insert_usb, Toast.LENGTH_LONG).show();                    if (isBootedByRecord()) {                        cancelValidEpgTimerEvent();                        standbySystem();                    }                    finish();                    return;                }                if (CHOOSE_DISK.equals(diskPath)) {                    Log.e(TAG, "choose disk");                    Log.e(TAG, "isBootedByRecord=" + isBootedByRecord());                    if (isBootedByRecord()) {                        // Screen cases recorded in authority, is automatically                        // choose the disk for recording.                        diskPath = getAvaliableDiskForStandBy();                        Log.e(TAG, "getAvaliableDiskForStandBy=" + diskPath);                        if (diskPath == null) {                            cancelValidEpgTimerEvent();                            standbySystem();                            return;                        }                    } else {                        usbSelecter.start();                        return;                    }                }                String diskLabel = getUsbLabelByPath(new String(diskPath));                recordDiskPath = diskPath;                recordDiskLable = diskLabel;                usbLabel.setText(diskLabel);                Log.d(TAG, "set disk to read information.");                try {                    if (isOneTouchPauseMode) {                        doPVRTimeShift(true);                        new PlayBackProgress().start();                    } else {                        String fat = "FAT";                        String ntfs = "NTFS";                        if (recordDiskLable.regionMatches(6, fat, 0, 3)) {                            doPVRRecord(true);                            new PlayBackProgress().start();                        } else if (recordDiskLable.regionMatches(6, ntfs, 0, 4) || !recordDiskLable.contains(fat)) {                            Toast.makeText(activity, R.string.str_pvr_unsurpt_flsystem, Toast.LENGTH_LONG).show();                            finish();                            if (isBootedByRecord()) {                                standbySystem();                            }                            return;                        }                    }                } catch (TvCommonException e) {                    e.printStackTrace();                }            }        } else if (pvr.isRecordPaused()) {            doPVRRecord(true);        } else {            doPVRRecord(false);        }    }    public void onKeyPlay() throws TvCommonException {        if (curPvrMode == PVR_MODE.E_PVR_MODE_NONE) {            return;        }        play.setImageResource(R.drawable.player_play_focus);        pvrImageFlag.setPlayFlag(true);        if (pvr.isTimeShiftRecording()) {            play.requestFocus();            playSpeed.setVisibility(View.GONE);            playSpeed.setText("");            if (pvr.getPlaybackSpeed() == EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_INVALID) {                if (pvr.isAlwaysTimeShiftPlaybackPaused()) {                    // not succeed                    if (pvr.startAlwaysTimeShiftPlayback() != 0) {                        Log.e(TAG, "startAlwaysTimeShiftPlayback is not E_SUCCESS!");                        return;                    }                } else {                    if (pvr.startTimeShiftPlayback() != EnumPvrStatus.E_SUCCESS) {                        Log.e(TAG, "startTimeShiftPlayback is not E_SUCCESS!");                        return;                    }                }            } else {                play.requestFocus();                switch (pvr.getPlaybackSpeed()) {                    case E_PVR_PLAYBACK_SPEED_0X:                        pvr.resumePlayback();                        break;                    case E_PVR_PLAYBACK_SPEED_STEP_IN:                        pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_1X);                        break;                    case E_PVR_PLAYBACK_SPEED_1X:                        OnClick_ABLoop();                        break;                    case E_PVR_PLAYBACK_SPEED_2XFF:                    case E_PVR_PLAYBACK_SPEED_4XFF:                    case E_PVR_PLAYBACK_SPEED_8XFF:                    case E_PVR_PLAYBACK_SPEED_16XFF:                    case E_PVR_PLAYBACK_SPEED_32XFF:                    case E_PVR_PLAYBACK_SPEED_1XFB:                    case E_PVR_PLAYBACK_SPEED_2XFB:                    case E_PVR_PLAYBACK_SPEED_4XFB:                    case E_PVR_PLAYBACK_SPEED_8XFB:                    case E_PVR_PLAYBACK_SPEED_16XFB:                    case E_PVR_PLAYBACK_SPEED_32XFB:                    case E_PVR_PLAYBACK_SPEED_FF_1_2X:                    case E_PVR_PLAYBACK_SPEED_FF_1_4X:                    case E_PVR_PLAYBACK_SPEED_FF_1_8X:                    case E_PVR_PLAYBACK_SPEED_FF_1_16X:                    case E_PVR_PLAYBACK_SPEED_FF_1_32X:                        pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_1X);                        break;                    default:                        break;                }            }        } else if (curPvrMode == PVR_MODE.E_PVR_MODE_PLAYBACK) {            play.requestFocus();            switch (pvr.getPlaybackSpeed()) {                case E_PVR_PLAYBACK_SPEED_0X:                    pvr.resumePlayback();                    break;                case E_PVR_PLAYBACK_SPEED_STEP_IN:                    pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_1X);                    break;                case E_PVR_PLAYBACK_SPEED_1X:                    OnClick_ABLoop();                    break;                case E_PVR_PLAYBACK_SPEED_2XFF:                case E_PVR_PLAYBACK_SPEED_4XFF:                case E_PVR_PLAYBACK_SPEED_8XFF:                case E_PVR_PLAYBACK_SPEED_16XFF:                case E_PVR_PLAYBACK_SPEED_32XFF:                case E_PVR_PLAYBACK_SPEED_1XFB:                case E_PVR_PLAYBACK_SPEED_2XFB:                case E_PVR_PLAYBACK_SPEED_4XFB:                case E_PVR_PLAYBACK_SPEED_8XFB:                case E_PVR_PLAYBACK_SPEED_16XFB:                case E_PVR_PLAYBACK_SPEED_32XFB:                case E_PVR_PLAYBACK_SPEED_FF_1_2X:                case E_PVR_PLAYBACK_SPEED_FF_1_4X:                case E_PVR_PLAYBACK_SPEED_FF_1_8X:                case E_PVR_PLAYBACK_SPEED_FF_1_16X:                case E_PVR_PLAYBACK_SPEED_FF_1_32X:                    pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_1X);                    break;                default:                    break;            }            playSpeed.setVisibility(View.VISIBLE);            playSpeed.setText("");        } else if (curPvrMode == PVR_MODE.E_PVR_MODE_RECORD) {            play.requestFocus();            if (pvr.isPlaybacking()) {                switch (pvr.getPlaybackSpeed()) {                    case E_PVR_PLAYBACK_SPEED_0X:                        pvr.resumePlayback();                        break;                    case E_PVR_PLAYBACK_SPEED_STEP_IN:                        pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_1X);                        break;                    case E_PVR_PLAYBACK_SPEED_1X:                        OnClick_ABLoop();                        break;                    case E_PVR_PLAYBACK_SPEED_2XFF:                    case E_PVR_PLAYBACK_SPEED_4XFF:                    case E_PVR_PLAYBACK_SPEED_8XFF:                    case E_PVR_PLAYBACK_SPEED_16XFF:                    case E_PVR_PLAYBACK_SPEED_32XFF:                    case E_PVR_PLAYBACK_SPEED_1XFB:                    case E_PVR_PLAYBACK_SPEED_2XFB:                    case E_PVR_PLAYBACK_SPEED_4XFB:                    case E_PVR_PLAYBACK_SPEED_8XFB:                    case E_PVR_PLAYBACK_SPEED_16XFB:                    case E_PVR_PLAYBACK_SPEED_32XFB:                    case E_PVR_PLAYBACK_SPEED_FF_1_2X:                    case E_PVR_PLAYBACK_SPEED_FF_1_4X:                    case E_PVR_PLAYBACK_SPEED_FF_1_8X:                    case E_PVR_PLAYBACK_SPEED_FF_1_16X:                    case E_PVR_PLAYBACK_SPEED_FF_1_32X:                        pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_1X);                        break;                    default:                        break;                }            } else {// record only                String strFileName = pvr.getCurRecordingFileName();                if (EnumPvrStatus.E_SUCCESS != pvr.startPlayback(strFileName)) {                    Log.e(TAG, "startPlayback is not E_SUCCESS!");                    return;                }                pvr.assignThumbnailFileInfoHandler(strFileName);                curPvrMode = PVR_MODE.E_PVR_MODE_PLAYBACK;            }        }        if (curPvrMode == PVR_MODE.E_PVR_MODE_SHORT) {            Log.e(TAG, "curPvrMode is SHORT!");        }        if (curPvrMode == PVR_MODE.E_PVR_MODE_PLAYBACK || curPvrMode == PVR_MODE.E_PVR_MODE_TIME_SHIFT) {            setBarStatusOfPlayToOthers();        } else {            setBarStatusOfRecordToPlay();        }        return;    }    public void onKeyStop() throws TvCommonException {        Log.e(TAG, "curPvrMode is :" + curPvrMode);        if (curPvrMode == PVR_MODE.E_PVR_MODE_NONE)            return;        if (curPvrMode == PVR_MODE.E_PVR_MODE_PLAYBACK || curPvrMode == PVR_MODE.E_PVR_MODE_RECORD                || curPvrMode == PVR_MODE.E_PVR_MODE_TIME_SHIFT) {            if (curPvrMode == PVR_MODE.E_PVR_MODE_PLAYBACK || curPvrMode == PVR_MODE.E_PVR_MODE_TIME_SHIFT) {                play.setImageResource(R.drawable.player_play);            }            if (pvr.isPlaybacking()) {                resumeLang();                resumeSubtitle();                if (pvrABLoopStartTime != INVALID_TIME) {                    pvr.stopPlaybackLoop();                    pvrABLoopStartTime = pvrABLoopEndTime = INVALID_TIME;                    progress_loopab.setVisibility(View.INVISIBLE);                    textViewPlay.setText(getString(R.string.str_player_play));                    if (isBrowserCalled) {                        finish();                    }                    return;                } else if (isOneTouchPlayMode) {                    pvr.stopPlayback();                    finish();                }            }        }        if (curPvrMode == PVR_MODE.E_PVR_MODE_RECORD) {// record & play            if (pvr.isPlaybacking()) {                // Reset_Start_Time();                pvr.stopPlayback();                setBarStatusOfRecordToPause();                pvrABLoopStartTime = pvrABLoopEndTime = INVALID_TIME;                return;            }            // record only            if (pvr.isRecording()) {                onBackPressed();                return;            }        } else if (curPvrMode == PVR_MODE.E_PVR_MODE_TIME_SHIFT) {            if (pvr.isPlaybacking()) {                // Reset_Start_Time();                pvr.stopPlayback();                setBarStatusOfRecordToPause();                pvrABLoopStartTime = pvrABLoopEndTime = INVALID_TIME;                return;            }            if (pvr.isTimeShiftRecording()) {                onBackPressed();                return;            }        } else if (curPvrMode == PVR_MODE.E_PVR_MODE_ALWAYS_TIME_SHIFT) {            if (pvr.isPlaybacking()) {                // close always time shift playback part.                pvr.stopAlwaysTimeShiftPlayback();            }            progress_loopab.setVisibility(View.INVISIBLE);            pvr.pauseAlwaysTimeShiftPlayback(false);            return;        } else if (curPvrMode == PVR_MODE.E_PVR_MODE_PLAYBACK) {            if (pvr.isPlaybacking()) {                pvr.stopPlayback();            }            if (pvr.isRecording()) {                pvrABLoopStartTime = pvrABLoopEndTime = INVALID_TIME;                setBarStatusOfRecordToPause();                // SetPlaySpeedIcon();                // DoValueUpdate_PVR_Playback_Time(0);                if (curPvrMode == PVR_MODE.E_PVR_MODE_PLAYBACK) {                    curPvrMode = PVR_MODE.E_PVR_MODE_RECORD;                }            } else {                finish();            }            return;        }        return;    }    public void onKeyPause() throws TvCommonException {        Log.e(TAG, "curPvrMode is :" + curPvrMode);        if (curPvrMode == PVR_MODE.E_PVR_MODE_NONE)            return;        if (pvr.isTimeShiftRecording()) {            if (!pvr.isPlaybacking()) {                // freeze img and setup start time                pvr.pauseAlwaysTimeShiftPlayback(true);                setBarStatusOfRecordToPause();            } else {                pvr.stepInPlayback(); // stop or pause                setBarStatusOfRecordToPause();            }        } else if (curPvrMode == PVR_MODE.E_PVR_MODE_PLAYBACK) {            Log.e(TAG, "stepInPlayback !!!!");            pvr.stepInPlayback(); // stop or pause            setBarStatusOfRecordToPause();        } else if (curPvrMode == PVR_MODE.E_PVR_MODE_RECORD) {            // record & play            if (pvr.isPlaybacking()) {                pvr.stepInPlayback();                // stop or pause                setBarStatusOfRecordToPause();            } else {                pvr.pauseRecord();            }        }        pause.requestFocus();        return;    }    /**     * To determine whether the current reversal.     *      * @return     */    private boolean isFastBackPlaying() {        EnumPvrPlaybackSpeed speed = pvr.getPlaybackSpeed();        if (speed.ordinal() >= EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_32XFB.ordinal()                && speed.ordinal() <= EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_1XFB.ordinal()) {            return true;        }        return false;    }    public void onKeyRev() throws TvCommonException {        if (pvr.isPlaybacking()) {            EnumPvrPlaybackSpeed curPlayBackSpeed = pvr.getPlaybackSpeed();            switch (curPlayBackSpeed) {                case E_PVR_PLAYBACK_SPEED_1XFB:                    pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_2XFB);                    playSpeed.setVisibility(View.VISIBLE);                    playSpeed.setText("2X");                    break;                case E_PVR_PLAYBACK_SPEED_2XFB:                    pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_4XFB);                    playSpeed.setVisibility(View.VISIBLE);                    playSpeed.setText("4X");                    break;                case E_PVR_PLAYBACK_SPEED_4XFB:                    pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_8XFB);                    playSpeed.setVisibility(View.VISIBLE);                    playSpeed.setText("8X");                    break;                case E_PVR_PLAYBACK_SPEED_8XFB:                    pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_16XFB);                    playSpeed.setVisibility(View.VISIBLE);                    playSpeed.setText("16X");                    break;                case E_PVR_PLAYBACK_SPEED_16XFB:                    pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_32XFB);                    playSpeed.setVisibility(View.VISIBLE);                    playSpeed.setText("32X");                    break;                case E_PVR_PLAYBACK_SPEED_32XFB:                    pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_1XFB);                    playSpeed.setVisibility(View.GONE);                    playSpeed.setText("");                    break;                default:                    pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_1XFB);                    playSpeed.setVisibility(View.GONE);                    playSpeed.setText("");                    break;            }            // pvr bar status change            setBarStatusOfPlayToOthers();        }    }    public void onKeyFF() throws TvCommonException {        if (pvr.isPlaybacking()) {            EnumPvrPlaybackSpeed curPlayBackSpeed = pvr.getPlaybackSpeed();            switch (curPlayBackSpeed) {                case E_PVR_PLAYBACK_SPEED_1X:                    pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_2XFF);                    playSpeed.setVisibility(View.VISIBLE);                    playSpeed.setText("2X");                    break;                case E_PVR_PLAYBACK_SPEED_2XFF:                    pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_4XFF);                    playSpeed.setVisibility(View.VISIBLE);                    playSpeed.setText("4X");                    break;                case E_PVR_PLAYBACK_SPEED_4XFF:                    pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_8XFF);                    playSpeed.setVisibility(View.VISIBLE);                    playSpeed.setText("8X");                    break;                case E_PVR_PLAYBACK_SPEED_8XFF:                    pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_16XFF);                    playSpeed.setVisibility(View.VISIBLE);                    playSpeed.setText("16X");                    break;                case E_PVR_PLAYBACK_SPEED_16XFF:                    pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_32XFF);                    playSpeed.setVisibility(View.VISIBLE);                    playSpeed.setText("32X");                    break;                case E_PVR_PLAYBACK_SPEED_32XFF:                    pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_1X);                    playSpeed.setVisibility(View.GONE);                    playSpeed.setText("");                    break;                default:                    pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_1X);                    playSpeed.setVisibility(View.GONE);                    playSpeed.setText("");                    break;            }            // pvr bar status change            setBarStatusOfPlayToOthers();        }    }    public void onKeySlowMotion() throws TvCommonException {        // slow motion        if (pvr.isPlaybacking()) {            EnumPvrPlaybackSpeed curPlayBackSpeed = pvr.getPlaybackSpeed();            switch (curPlayBackSpeed) {                case E_PVR_PLAYBACK_SPEED_STEP_IN:                    pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_FF_1_2X);                    playSpeed.setVisibility(View.VISIBLE);                    playSpeed.setText("Slow/2");                    break;                case E_PVR_PLAYBACK_SPEED_FF_1_32X:                    pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_1X);                    playSpeed.setVisibility(View.GONE);                    playSpeed.setText("");                    break;                case E_PVR_PLAYBACK_SPEED_FF_1_16X:                    pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_FF_1_32X);                    playSpeed.setVisibility(View.VISIBLE);                    playSpeed.setText("Slow/32");                    break;                case E_PVR_PLAYBACK_SPEED_FF_1_8X:                    pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_FF_1_16X);                    playSpeed.setVisibility(View.VISIBLE);                    playSpeed.setText("Slow/16");                    break;                case E_PVR_PLAYBACK_SPEED_FF_1_4X:                    pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_FF_1_8X);                    playSpeed.setVisibility(View.VISIBLE);                    playSpeed.setText("Slow/8");                    break;                case E_PVR_PLAYBACK_SPEED_FF_1_2X:                    pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_FF_1_4X);                    playSpeed.setVisibility(View.VISIBLE);                    playSpeed.setText("Slow/4");                    break;                default:                    pvr.setPlaybackSpeed(EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_FF_1_2X);                    playSpeed.setVisibility(View.VISIBLE);                    playSpeed.setText("Slow/2");                    break;            }            // pvr bar status change            setBarStatusOfPlayToOthers();        }    }    public void onKeyGoToTime() throws TvCommonException {        if (pvr.isPlaybacking()) {            myHandler.removeMessages(MENUDISMISS);            showDialog(timeChoose);        }    }    public void onKeyBackward() throws TvCommonException {        int PVRCurPlaybackTime = 0;        // for ATshift        if (!pvr.isPlaybacking() && pvr.isRecording() && curPvrMode == PVR_MODE.E_PVR_MODE_ALWAYS_TIME_SHIFT) {            if (pvr.isAlwaysTimeShiftPlaybackPaused()) {                if (pvr.startAlwaysTimeShiftPlayback() != 0) {                    return;                }            } else {                pvr.pauseAlwaysTimeShiftPlayback(true);                if (pvr.startAlwaysTimeShiftPlayback() != 0) {                    return;                }                setBarStatusOfRecordToPause();                play.requestFocus();            }            // update time            PVRCurPlaybackTime = pvr.getCurPlaybackTimeInSecond();            setBarStatusOfPlayToOthers();        }        if (pvr.isPlaybacking() && !pvr.isPlaybackPaused()                && pvr.getPlaybackSpeed() != EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_STEP_IN) {            PVRCurPlaybackTime = pvr.getCurPlaybackTimeInSecond();            if (PVRCurPlaybackTime > 30) {                // Normal Jump Backward                pvr.jumpPlaybackTime(PVRCurPlaybackTime - 30);            } else {                // Jump To Head                pvr.jumpPlaybackTime(0);            }        }        return;    }    public void onKeyForward() throws TvCommonException {        // backward        if (pvr.isPlaybacking() && !pvr.isPlaybackPaused()                && pvr.getPlaybackSpeed() != EnumPvrPlaybackSpeed.E_PVR_PLAYBACK_SPEED_STEP_IN) {            TvManager.getInstance().getPvrManager().doPlaybackJumpForward();        }        // pvr bar status change        setBarStatusOfPlayToOthers();    }    public void onKeyCapture() throws TvCommonException {        // capture        if (!pvr.isTimeShiftRecording() && pvr.isPlaybacking()) {            CaptureThumbnail();        }        // pvr bar status change        setBarStatusOfPlayToOthers();    }    private void OnClick_ABLoop() throws TvCommonException {        if (setPvrABLoop == PVR_AB_LOOP_STATUS.E_PVR_AB_LOOP_STATUS_NONE) {            pvrABLoopStartTime = pvr.getCurPlaybackTimeInSecond();            setPvrABLoop = PVR_AB_LOOP_STATUS.E_PVR_AB_LOOP_STATUS_A;            textViewPlay.setText(getString(R.string.str_player_play) + " A");            A_progress = RPProgress.getProgress();            int x = RPProgress.getWidth() * A_progress / (RPProgress.getMax() == 0 ? 1 : RPProgress.getMax());            lp4LoopAB.leftMargin = x;            looptime = 0;            progress_loopab.setMax(looptime);            progress_loopab.setProgress(looptime);            progress_loopab.setLayoutParams(lp4LoopAB);            progress_loopab.setVisibility(View.VISIBLE);        } else if (setPvrABLoop == PVR_AB_LOOP_STATUS.E_PVR_AB_LOOP_STATUS_A) {            pvrABLoopEndTime = pvr.getCurPlaybackTimeInSecond();            Log.e(TAG, "b-a=" + (pvrABLoopEndTime - pvrABLoopStartTime));            if (pvrABLoopEndTime - pvrABLoopStartTime <= 2) {                Toast.makeText(this, R.string.pvraberror, Toast.LENGTH_SHORT).show();                return;            }            pvr.startPlaybackLoop(pvrABLoopStartTime, pvrABLoopEndTime);            setPvrABLoop = PVR_AB_LOOP_STATUS.E_PVR_AB_LOOP_STATUS_AB;            textViewPlay.setText(getString(R.string.str_player_play) + " A-B");            lp4LoopAB.width = (RPProgress.getProgress() - A_progress) * RPProgress.getWidth()                    / (RPProgress.getMax() == 0 ? 1 : RPProgress.getMax());            progress_loopab.setLayoutParams(lp4LoopAB);            looptime++;            progress_loopab.setMax(looptime);            currentlooptime = 0;        } else {            pvr.stopPlaybackLoop();            setPvrABLoop = PVR_AB_LOOP_STATUS.E_PVR_AB_LOOP_STATUS_NONE;            textViewPlay.setText(getString(R.string.str_player_play));            lp4LoopAB.width = 0;            progress_loopab.setMax(0);            progress_loopab.setVisibility(View.GONE);        }    }    private int dip2px(int dipValue) {        float scale = getResources().getDisplayMetrics().density;        return (int) (dipValue * scale + 0.5f);    }    private void doPVRRecord(boolean type) throws TvCommonException {        if (!(curPvrMode == PVR_MODE.E_PVR_MODE_PLAYBACK || curPvrMode == PVR_MODE.E_PVR_MODE_TIME_SHIFT)) {            play.setImageResource(R.drawable.player_play);        }        if (type) {            recorder.setImageResource(R.drawable.player_recorder_focus);            recordingView.setVisibility(View.VISIBLE);            pvrImageFlag.setRecorderFlag(true);            recordIconAnimation.start();            if (pvr.isRecordPaused()) {                pvr.resumeRecord();                return;            }            if (!pvr.isRecording()) {                String fat = "FAT";                String ntfs = "NTFS";                if (recordDiskPath.isEmpty()) {                    Log.e(TAG, "USB Disk Path is NULL !!!");                    return;                }                Log.d(TAG, "USB Disk Path = " + recordDiskPath);                Log.d(TAG, "USB Disk Label = " + recordDiskLable);                if (recordDiskLable.regionMatches(6, fat, 0, 3)) {                    pvr.setPvrParams(recordDiskPath, (short) 2);                } else if (recordDiskLable.regionMatches(6, ntfs, 0, 4)) {                    Toast.makeText(PVRActivity.this, R.string.formattip, Toast.LENGTH_SHORT).show();                    return;                }            }            if (!pvr.isRecording()) {                EnumPvrStatus status = pvr.startRecord();                Log.e(TAG, "status=" + status);                if (status.ordinal() != EnumPvrStatus.E_SUCCESS.ordinal()) {                    if (isBootedByRecord()) {                        cancelValidEpgTimerEvent();                        standbySystem();                        return;                    }                    if (status == EnumPvrStatus.E_ERROR_RECORD_OUT_OF_DISK_SPACE) {                        Toast.makeText(this, R.string.pvrrecordfull, Toast.LENGTH_LONG).show();                    } else {                        Toast.makeText(this, R.string.pvrrecordfail, Toast.LENGTH_LONG).show();                    }                    if (pvr.isPlaybacking()) {                        resumeLang();                        resumeSubtitle();                        pvr.stopPlayback();                        pvr.stopPlaybackLoop();                    }                    if (pvr.isTimeShiftRecording()) {                        pvr.stopTimeShift();                    }                    PVRActivity.currentRecordingProgrammFrency = -1;                    saveAndExit();                    return;                }            }            currentRecordingProgrammFrency = ChannelManagerExt.getInstance().getCurInfo().frequency;            curPvrMode = PVR_MODE.E_PVR_MODE_RECORD;            String strFileName = pvr.getCurRecordingFileName();            Log.d(TAG, "doPVRRecord: current recording fileName = " + strFileName);            PlayerActivity.mLastRecordedFileName = strFileName;        } else {            recordingView.setVisibility(View.GONE);            recordIconAnimation.end();            recorder.setImageResource(R.drawable.player_recorder);            pvr.pauseRecord();        }    }    private void doPVRTimeShift(boolean type) throws TvCommonException {        // stop or pause        pvr.stepInPlayback();        setBarStatusOfStartRecord();        recorder.setEnabled(false);        recorder.setFocusable(false);        if (type) {            recorder.setImageResource(R.drawable.player_recorder_focus);            recordingView.setVisibility(View.VISIBLE);            pvrImageFlag.setRecorderFlag(false);            recordIconAnimation.start();            currentRecordingProgrammFrency = ChannelManagerExt.getInstance().getCurInfo().frequency;            if (pvr.isRecordPaused()) {                pvr.resumeRecord();                return;            }            pvr.setPvrParams(recordDiskPath, (short) 2);            EnumPvrStatus statue = pvr.startTimeShiftRecord();            if (statue == EnumPvrStatus.E_ERROR_TIMESHIFT_OUT_OF_DISK_SPACE) {                Toast.makeText(this, R.string.str_pvr_timeshift_filespaceerror, Toast.LENGTH_LONG).show();                finish();            }            curPvrMode = PVR_MODE.E_PVR_MODE_TIME_SHIFT;        } else {            recordingView.setVisibility(View.GONE);            recordIconAnimation.end();            recorder.setImageResource(R.drawable.player_recorder);            pvr.stopTimeShiftRecord();        }    }    private void resumeSubtitle() {        // DtvSubtitleInfo subtitleInfo;        // TvChannelManager cd = TvChannelManager.getInstance();        //        // subtitleInfo = cd.getSubtitleInfo();        // if (subtitleInfo != null) {        // if (subtitlePosLive != -1 && subtitlePosLive <=        // subtitleInfo.subtitleServiceNumber        // && subtitlePosLive != subtitleInfo.currentSubtitleIndex + 1) {        // cd.closeSubtitle();        // cd.openSubtitle((subtitlePosLive - 1));        // SharedPreferences settings = getSharedPreferences("TvSetting", 0);        // Editor editor = settings.edit();        // editor.putInt("subtitlePos", subtitlePosLive);        // editor.commit();        // subtitlePosLive = -1;        // }        // }    }    private void resumeLang() {        DtvAudioInfo audioInfo = new DtvAudioInfo();        TvChannelManager cd = TvChannelManager.getInstance();        audioInfo = cd.getAudioInfo();        if (audioInfo != null) {            if (audioLangPosLive != -1 && audioInfo.audioLangNum > audioLangPosLive                    && audioInfo.currentAudioIndex != audioLangPosLive) {                cd.switchAudioTrack(audioLangPosLive);                audioLangPosLive = -1;            }        }    }    private void saveAndExit() {        Log.e(TAG, "saveAndExit()");        showDialog(savingProgress);        pvr.stopRecord();        new Thread(new Runnable() {            @Override            public void run() {                handler.postDelayed(new Runnable() {                    @Override                    public void run() {                        recorder.setImageResource(R.drawable.player_recorder);                        pvrImageFlag.setRecorderFlag(false);                        if (!isFinishing()) {                            dismissDialog(savingProgress);                        }                        Log.e(TAG, "finish()");                        finish();                    }                }, 1500);            }        }).start();    }    private void updateUSBInfo() {        StatFs sf = new StatFs(recordDiskPath);        int percent = (int) ((1 - (float) sf.getFreeBlocks() / sf.getBlockCount()) * 100);        usbPercentage.setText(percent + "%");        usbFreeSpace.setProgress(percent);        if (percent > 98) {            Toast.makeText(PVRActivity.this, R.string.pvr_disk_full, Toast.LENGTH_LONG).show();            if (pvr.isPlaybacking()) {                resumeLang();                resumeSubtitle();                pvr.stopPlayback();                pvr.stopPlaybackLoop();            }            if (pvr.isTimeShiftRecording()) {                pvr.stopTimeShift();            }            PVRActivity.currentRecordingProgrammFrency = -1;            saveAndExit();        }    }    private void createAnimation() {        if (menuShowAnimation != null && menuHideAnimation != null) {            return;        }        int height = rootView.getHeight() + rootView.getPaddingBottom();        ObjectAnimator fadeInAlphaAnim = ObjectAnimator.ofFloat(rootView, "alpha", 0f, 1f);        fadeInAlphaAnim.setInterpolator(new DecelerateInterpolator());        fadeInAlphaAnim.setDuration(300);        ObjectAnimator fadeOutAlphaAnim = ObjectAnimator.ofFloat(rootView, "alpha", 1f, 0f);        fadeOutAlphaAnim.setInterpolator(new DecelerateInterpolator());        fadeOutAlphaAnim.setDuration(300);        ObjectAnimator moveUpAnim = ObjectAnimator.ofFloat(rootView, "translationY", height, 0);        moveUpAnim.setInterpolator(new DecelerateInterpolator());        moveUpAnim.setDuration(300);        ObjectAnimator moveDownAnim = ObjectAnimator.ofFloat(rootView, "translationY", 0, height);        moveDownAnim.setInterpolator(new DecelerateInterpolator());        moveDownAnim.setDuration(300);        menuShowAnimation = new AnimatorSet();        menuHideAnimation = new AnimatorSet();        recordIconAnimation = new AnimatorSet();        menuShowAnimation.play(moveUpAnim).with(fadeInAlphaAnim);        menuHideAnimation.play(moveDownAnim).with(fadeOutAlphaAnim);        menuShowAnimation.addListener(new AnimatorListenerAdapter() {            @Override            public void onAnimationStart(Animator animation) {                isMenuHide = false;                rootView.setVisibility(View.VISIBLE);                rootView.requestFocus();            }        });        menuHideAnimation.addListener(new AnimatorListenerAdapter() {            @Override            public void onAnimationEnd(Animator animation) {                rootView.setVisibility(View.GONE);                isMenuHide = true;            }        });        fadeOutAlphaAnim = ObjectAnimator.ofFloat(recordingView.findViewById(R.id.pvrrecordimage), "alpha", 1f, 0f);        fadeOutAlphaAnim.setInterpolator(new AccelerateDecelerateInterpolator());        fadeOutAlphaAnim.setDuration(2000);        fadeOutAlphaAnim.setRepeatCount(Animation.INFINITE);        fadeOutAlphaAnim.setRepeatMode(Animation.RESTART);        fadeOutAlphaAnim.addListener(new AnimatorListener() {            int count = 0;            TextView text = (TextView) recordingView.findViewById(R.id.pvrrecordtext);            @Override            public void onAnimationStart(Animator animation) {                text.setText(mPvrRecordStr + ".");            }            @Override            public void onAnimationRepeat(Animator animation) {                String str = mPvrRecordStr;                for (int i = 0; i < count + 1; i++) {                    str += ".";                }                text.setText(str);                count = (count + 1) % 8;            }            @Override            public void onAnimationEnd(Animator animation) {            }            @Override            public void onAnimationCancel(Animator animation) {            }        });        recordIconAnimation.play(fadeOutAlphaAnim);    }    private void menuShow() {        Log.d(TAG, "menuShow is " + isMenuHide);        if (isMenuHide && (menuShowAnimation != null && menuHideAnimation != null)) {            menuHideAnimation.end();            menuShowAnimation.start();        }    }    private boolean CaptureThumbnail() throws TvCommonException {        CaptureThumbnailResult result = pvr.captureThumbnail();        Log.d(TAG, "result.getPvrThumbnailStatus() = " + result.getPvrThumbnailStatus());        switch (result.getPvrThumbnailStatus()) {            case E_OK:                if (false == AddThumbnail(result.thumbnailIndex)) {                    Log.d(TAG, "AddThumbnail fail !!! ");                    return false;                }                break;            case E_REPLACE:// clear cache image in MW_PVR                break;            default:                Log.e(TAG, "capture fail !!!\n");                return false;        }        if (thumbnail.isShown())            thumbnail.setSelection(result.thumbnailIndex);        return true;    }    private boolean AddThumbnail(int index) {        return thumbnail.addThumbnail(index);    }    private boolean RemoveThumbnail() {        if (!thumbnail.isShown())            return false;        int index = thumbnail.getSelectedItemPosition();        boolean result = false;        if (result) {            thumbnail.removeViewAt(index);            return true;        } else            return false;    }    private boolean JumpToThumbnail(int index) {        boolean result = false;        result = pvr.jumpToThumbnail(index);        return result;    }    private class PlayBackProgress extends Thread {        @Override        public void run() {            super.run();            try {                // Only [Record] & [TimeShift] mode need to update USB info.                if (pvr.isRecording() || pvr.isTimeShiftRecording()) {                    new usbInfoUpdate().start();                }                while ((pvr.isPlaybacking() || pvr.isRecording()) && !isFinishing()) {                    final int currentTime = pvr.getCurPlaybackTimeInSecond();                    final int total = (pvr.isRecording() && !isWatchRcodFilInRcoding) ? pvr.getCurRecordTimeInSecond()                            : pvr.getRecordedFileDurationTime(pvr.getCurPlaybackingFileName());                    Log.d(TAG, "current time = " + currentTime);                    handler.post(new Runnable() {                        @Override                        public void run() {                            RPProgress.setMax(total);                            if (setPvrABLoop == PVR_AB_LOOP_STATUS.E_PVR_AB_LOOP_STATUS_AB) {                                currentlooptime++;                                RPProgress.setTextProgress(getTimeString(currentTime), 0);                                Log.i(TAG, "looptime:" + looptime);                                progress_loopab.setProgress(currentlooptime % looptime + 1);                                Log.i(TAG, "max:" + progress_loopab.getMax());                                Log.i(TAG, "current" + progress_loopab.getProgress());                            } else {                                RPProgress.setTextProgress(getTimeString(currentTime), currentTime);                            }                            totalRecordTime.setText(getTimeString(total));                            // ham                            if (setPvrABLoop == PVR_AB_LOOP_STATUS.E_PVR_AB_LOOP_STATUS_A) {                                lp4LoopAB.width = (RPProgress.getProgress() - A_progress) * RPProgress.getWidth()                                        / (RPProgress.getMax() == 0 ? 1 : RPProgress.getMax());                                looptime++;                                progress_loopab.setLayoutParams(lp4LoopAB);                            }                            Log.e(TAG, "isPlaybacking=" + pvr.isPlaybacking());                            Log.e(TAG, "isFastBackPlaying=" + isFastBackPlaying());                            if ((pvr.isPlaybacking() && ((currentTime >= total)))                                    || (pvr.isPlaybacking() && isFastBackPlaying() && currentTime <= 0)) {                                resumeLang();                                resumeSubtitle();                                pvr.stopPlayback();                                pvr.stopPlaybackLoop();                                if (pvr.isTimeShiftRecording()) {                                    pvr.stopTimeShiftRecord();                                }                                finish();                            }                        }                    });                    Thread.sleep(1000);                }            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    private class BrowserCalledPlayBackProgress extends Thread {        @Override        public void run() {            super.run();            try {                while ((pvr.isPlaybacking() || pvr.isRecording()) && !isFinishing()) {                    final int currentTime = pvr.getCurPlaybackTimeInSecond();                    final int total = pvr.getRecordedFileDurationTime(pvr.getCurPlaybackingFileName());                    Log.e(TAG, "current time = " + currentTime);                    Log.e(TAG, "tatal Time=" + total);                    handler.post(new Runnable() {                        @Override                        public void run() {                            RPProgress.setTextProgress(getTimeString(currentTime), currentTime);                            // ham                            if (setPvrABLoop == PVR_AB_LOOP_STATUS.E_PVR_AB_LOOP_STATUS_A) {                                lp4LoopAB.width = (RPProgress.getProgress() - A_progress) * RPProgress.getWidth()                                        / (RPProgress.getMax() == 0 ? 1 : RPProgress.getMax());                                looptime++;                                progress_loopab.setLayoutParams(lp4LoopAB);                            }                            if ((pvr.isPlaybacking() && ((currentTime >= total)))                                    || (pvr.isPlaybacking() && isFastBackPlaying() && currentTime <= 0)) {                                resumeLang();                                resumeSubtitle();                                if (isBrowserCalled) {                                    pvr.jumpPlaybackTime(0);                                    Intent intent = new Intent(PVRActivity.this, PVRFullPageBrowserActivity.class);                                    startActivity(intent);                                } else {                                    pvr.stopPlayback();                                    pvr.stopPlaybackLoop();                                }                                finish();                            }                        }                    });                    Thread.sleep(1000);                }            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    private class usbInfoUpdate extends Thread {        @Override        public void run() {            super.run();            try {                while (!isFinishing()) {                    handler.post(new Runnable() {                        @Override                        public void run() {                            updateUSBInfo();                        }                    });                    Thread.sleep(5000);                }            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    private String getTimeString(int seconds) {        String hour = "00";        String minute = "00";        String second = "00";        if (seconds % 60 < 10)            second = "0" + seconds % 60;        else            second = "" + seconds % 60;        int offset = seconds / 60;        if (offset % 60 < 10)            minute = "0" + offset % 60;        else            minute = "" + offset % 60;        offset = seconds / 3600;        if (offset < 10)            hour = "0" + offset;        else            hour = "" + offset;        return hour + ":" + minute + ":" + second;    }    @Override    protected void onPause() {        saveAndExit();        super.onPause();    }    @Override    protected void onStop() {        super.onStop();        unregisterReceiver(usbReceiver);        usbReceiver = null;        isPVRActivityActive = false;    }    private class MyUsbReceiver extends BroadcastReceiver {        @Override        public void onReceive(Context context, Intent intent) {            String action = intent.getAction();            Uri uri = intent.getData();            String path = uri.getPath();            if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {            } else if (action.equals(Intent.ACTION_MEDIA_EJECT)) {                String mountPath = null;                mountPath = pvr.getPvrMountPath();                String tmp = path;// Lost the path of the disk.                // Only remove the disk path is the same as the current PVR                // mountpath to close the interface. Otherwise, remove the usb                // does not remove the related equipment.                if (tmp.equals(mountPath)) {                    pvr.clearMetadata();                    finish();                }            }        }    }}